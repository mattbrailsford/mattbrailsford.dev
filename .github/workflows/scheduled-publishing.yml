# .github/workflows/scheduled-publishing.yml
name: Scheduled Publishing

env:
  BLOG_CATEGORY: "Blog Post"
  IGNORE_LABELS: "state/draft"
  SCHEDULED_LABEL: "state/scheduled"
  TIMEZONE_LOCATION: "Europe/London"

on:
  schedule:
    - cron: '*/15 * * * *'
  discussion:
    types: [created, edited, labeled, unlabeled]
  workflow_dispatch:

jobs:
  check-and-publish:
    runs-on: ubuntu-latest
    steps:
      - name: Check for posts ready to publish
        uses: actions/github-script@v7
        if: |
          github.event_name != 'discussion' ||
          github.event.action == 'created' ||
          github.event.action == 'edited' ||
          (
            (github.event.action == 'labeled' || github.event.action == 'unlabeled') &&
            github.event.label.name != env.SCHEDULED_LABEL
          )
        env:
          NETLIFY_HOOK_URL: ${{ secrets.NETLIFY_BUILD_HOOK }}
        with:
          github-token: ${{ secrets.GH_PAT_TOKEN }}
          script: |
            const CONFIG = {
              blogCategory: process.env.BLOG_CATEGORY,
              ignoreLabels: (process.env.IGNORE_LABELS || '').split(',').map(s => s.trim()).filter(Boolean),
              scheduledLabel: process.env.SCHEDULED_LABEL,
              timezoneLocation: process.env.TIMEZONE_LOCATION || 'UTC'
            };

            const utils = 
            {
              // --- Timezone helpers ---
              tzOffsetForInstant(timeZone, dateUtc) {
                const dtf = new Intl.DateTimeFormat('en-US', {
                  timeZone,
                  hour12: false,
                  year: 'numeric',
                  month: '2-digit',
                  day: '2-digit',
                  hour: '2-digit',
                  minute: '2-digit',
                  second: '2-digit'
                });
                const parts = Object.fromEntries(dtf.formatToParts(dateUtc).map(p => [p.type, p.value]));
                const asUTC = Date.UTC(
                  Number(parts.year),
                  Number(parts.month) - 1,
                  Number(parts.day),
                  Number(parts.hour),
                  Number(parts.minute),
                  Number(parts.second)
                );
                return Math.round((asUTC - dateUtc.getTime()) / 60000);
              },

              resolveLocalToUTC(dateStr, timeZone) {
                const m = dateStr.match(/^(\d{4})-(\d{2})-(\d{2})(?:[T ](\d{2}):(\d{2})(?::(\d{2}))?)?$/);
                if (!m) return null;
                const [ , Y, Mo, D, h='00', mi='00', s='00' ] = m;
                let candidate = Date.UTC(+Y, +Mo - 1, +D, +h, +mi, +s);
                for (let i = 0; i < 2; i++) {
                  const offsetMin = this.tzOffsetForInstant(timeZone, new Date(candidate));
                  candidate = Date.UTC(+Y, +Mo - 1, +D, +h, +mi, +s) - offsetMin * 60000;
                }
                return new Date(candidate);
              },

              fmtOffset(totalMinutes) {
                const sign = totalMinutes >= 0 ? '+' : '-';
                const abs = Math.abs(totalMinutes);
                const hh = String(Math.floor(abs / 60)).padStart(2, '0');
                const mm = String(abs % 60).padStart(2, '0');
                return `${sign}${hh}:${mm}`;
              },

              // --- Build trigger ---
              async triggerBuild(reason = '') {
                try {
                  await fetch(process.env.NETLIFY_HOOK_URL, { method: 'POST' });
                  console.log(`✅ Build triggered${reason ? ': ' + reason : ''}`);
                  return true;
                } catch (error) {
                  console.error('❌ Error triggering build:', error.message);
                  return false;
                }
              },

              // --- Date parsing ---
              parseDateTime(dateStr) {
                console.log(`Parsing date string: "${dateStr}"`);
                if (/[zZ]$/.test(dateStr) || /[+-]\d{2}:\d{2}$/.test(dateStr)) {
                  const d = new Date(dateStr);
                  if (isNaN(d)) {
                    console.log(`❌ Invalid date format (with TZ): "${dateStr}"`);
                    return null;
                  }
                  console.log(`✅ Parsed with explicit timezone: ${d.toISOString()}`);
                  return d;
                }
                try {
                  const resolved = this.resolveLocalToUTC(dateStr, CONFIG.timezoneLocation);
                  if (!resolved || isNaN(resolved)) {
                    console.log(`❌ Could not resolve local time for "${dateStr}" in ${CONFIG.timezoneLocation}`);
                    return null;
                  }
                  const offsetMin = this.tzOffsetForInstant(CONFIG.timezoneLocation, resolved);
                  console.log(`Applied ${CONFIG.timezoneLocation} offset ${this.fmtOffset(offsetMin)} → ${resolved.toISOString()}`);
                  return resolved;
                } catch (err) {
                  console.log(`❌ Error parsing date "${dateStr}": ${err.message}`);
                  return null;
                }
              },

              parsePublishDate(discussion, now) {
                const fm = discussion.body.match(/^---\s*\r?\n([\s\S]*?)\r?\n---\s*(\r?\n|$)/);
                if (!fm) return { publishDate: now, hasExplicitDate: false };
                const publishedMatch = fm[1].match(/published:\s*(.+)/);
                if (!publishedMatch) return { publishDate: now, hasExplicitDate: false };
                const publishedStr = publishedMatch[1].trim().replace(/^['"]|['"]$/g, '');
                console.log(`Found published field: "${publishedStr}"`);
                const parsed = this.parseDateTime(publishedStr);
                if (!parsed) {
                  console.log('Failed to parse date, defaulting to now');
                  return { publishDate: now, hasExplicitDate: false };
                }
                return { publishDate: parsed, hasExplicitDate: true };
              },

              // --- Validation ---
              isValidBlogPost(discussion) {
                if (discussion.category?.name !== CONFIG.blogCategory) {
                  return { valid: false, reason: `Not a ${CONFIG.blogCategory} post` };
                }
                const postLabels = discussion.labels?.map(l => l.name) || [];
                const hasIgnore = CONFIG.ignoreLabels.some(il => postLabels.includes(il));
                if (hasIgnore) {
                  const matched = CONFIG.ignoreLabels.filter(il => postLabels.includes(il));
                  return { valid: false, reason: `Post has ignore label(s): ${matched.join(', ')}` };
                }
                return { valid: true };
              },

              // --- Label Handling ---
              async addScheduledLabel(discussionNumber) {
                try {
                  const labelsQuery = await github.rest.issues.listLabelsForRepo({
                    owner: context.repo.owner,
                    repo: context.repo.repo
                  });

                  let scheduledLabelObj = labelsQuery.data.find(l => l.name === CONFIG.scheduledLabel);
                  if (!scheduledLabelObj) {
                    console.log(`Creating ${CONFIG.sCHEDULED_LABEL} label...`);
                    const newLabel = await github.rest.issues.createLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      name: CONFIG.scheduledLabel,
                      color: 'D4C5F9',
                      description: 'Post scheduled for future publication'
                    });
                    scheduledLabelObj = newLabel.data;
                  }

                  const discussionResult = await github.graphql(`
                    query($owner: String!, $repo: String!, $number: Int!) {
                      repository(owner: $owner, name: $repo) {
                        discussion(number: $number) { id }
                      }
                    }`,
                    { owner: context.repo.owner, repo: context.repo.repo, number: discussionNumber }
                  );

                  const discussionId = discussionResult.repository.discussion.id;

                  await github.graphql(`
                    mutation($discussionId: ID!, $labelIds: [ID!]!) {
                      addLabelsToLabelable(input: { labelableId: $discussionId, labelIds: $labelIds }) { clientMutationId }
                    }`,
                    { discussionId, labelIds: [scheduledLabelObj.node_id] }
                  );

                  console.log(`✅ Added ${CONFIG.scheduledLabel} label to discussion #${discussionNumber}`);
                } catch (error) {
                  console.warn(`Failed to add scheduled label: ${error.message}`);
                }
              },

              async removeScheduledLabel(discussionNumber) {
                try {
                  const labelsQuery = await github.rest.issues.listLabelsForRepo({
                    owner: context.repo.owner,
                    repo: context.repo.repo
                  });
                  const scheduledLabelObj = labelsQuery.data.find(l => l.name === CONFIG.scheduledLabel);
                  if (!scheduledLabelObj) {
                    console.log(`${CONFIG.scheduledLabel} label doesn't exist, nothing to remove`);
                    return;
                  }

                  const discussionResult = await github.graphql(`
                    query($owner: String!, $repo: String!, $number: Int!) {
                      repository(owner: $owner, name: $repo) {
                        discussion(number: $number) { id }
                      }
                    }`,
                    { owner: context.repo.owner, repo: context.repo.repo, number: discussionNumber }
                  );

                  const discussionId = discussionResult.repository.discussion.id;

                  await github.graphql(`
                    mutation($discussionId: ID!, $labelIds: [ID!]!) {
                      removeLabelsFromLabelable(input: { labelableId: $discussionId, labelIds: $labelIds }) { clientMutationId }
                    }`,
                    { discussionId, labelIds: [scheduledLabelObj.node_id] }
                  );

                  console.log(`✅ Removed ${CONFIG.scheduledLabel} label from discussion #${discussionNumber}`);
                } catch (error) {
                  console.log(`Could not remove scheduled label: ${error.message} (may not exist)`);
                }
              }
            };

            // ===== MAIN =====
            const eventType = context.eventName;
            const now = new Date();
            console.log(`🚀 Running ${eventType} workflow at ${now.toISOString()}`);

            if (eventType === 'discussion') {
              const discussion = context.payload.discussion;
              console.log(`Discussion event: #${discussion.number} - "${discussion.title}"`);

              if (context.payload.action === 'labeled' || context.payload.action === 'unlabeled') {
                const changedLabel = context.payload.label?.name;
                if (CONFIG.ignoreLabels.includes(changedLabel)) {
                  if (context.payload.action === 'labeled') {
                    console.log(`📋 Ignore label "${changedLabel}" added — post will be ignored`);
                    await utils.removeScheduledLabel(discussion.number);
                    return;
                  } else {
                    console.log(`📝 Ignore label "${changedLabel}" removed — rechecking`);
                    // fall through
                  }
                } else {
                  console.log(`Label change (${changedLabel}) not relevant to publishing, skipping`);
                  return;
                }
              }

              const validation = utils.isValidBlogPost(discussion);
              if (!validation.valid) {
                console.log(validation.reason + ', skipping');
                return;
              }

              const { publishDate, hasExplicitDate } = utils.parsePublishDate(discussion, now);
              console.log(`Published date: ${publishDate.toISOString()}${!hasExplicitDate ? ' (defaulted to now)' : ''}`);

              if (publishDate > now) {
                const timeUntil = Math.round((publishDate - now) / 60000);
                console.log(`Post scheduled for future (${timeUntil} minutes from now), will be published by scheduled check`);
                await utils.addScheduledLabel(discussion.number);
                return;
              }

              await utils.removeScheduledLabel(discussion.number);
              console.log(`📝 Triggering immediate build for "${discussion.title}"`);
              await utils.triggerBuild('immediate publish');
              return;
            }

            // Scheduled/manual run: scan scheduled posts
            console.log('🔍 Checking discussions with scheduled label...');
            const result = await github.graphql(`
              query($repo: String!, $owner: String!, $category: String!, $label: String!) {
                search(query: "repo:$owner/$repo category:\\"$category\\" label:$label", type: DISCUSSION, first: 100) {
                  edges { node { ... on Discussion { id number title body createdAt } } }
                }
              }`,
              { repo: context.repo.repo, owner: context.repo.owner, category: CONFIG.blogCategory, label: CONFIG.scheduledLabel }
            );

            if (!result.search.edges.length) {
              console.log(`No posts with ${CONFIG.scheduledLabel} label found`);
              return;
            }

            const now2 = new Date();
            const ready = [];
            const future = [];

            for (const edge of result.search.edges) {
              const d = edge.node;
              const { publishDate } = utils.parsePublishDate(d, now2);
              if (publishDate <= now2) {
                ready.push({ id: d.id, title: d.title, number: d.number, publishedDate: publishDate });
              } else {
                future.push({ title: d.title, number: d.number, publishedDate: publishDate });
              }
            }

            if (future.length) {
              console.log(`📅 ${future.length} posts still scheduled for future:`);
              future.sort((a,b) => a.publishedDate - b.publishedDate).forEach(p => {
                const mins = Math.round((p.publishedDate - now2) / 60000);
                console.log(`- "${p.title}" in ${mins} minutes (${p.publishedDate.toISOString()})`);
              });
            }

            if (!ready.length) {
              console.log('No posts ready to publish now');
              return;
            }

            console.log(`Found ${ready.length} posts ready to publish:`);
            ready.forEach(p => console.log(`- "${p.title}" (Discussion #${p.number})`));

            console.log('Removing scheduled labels and triggering build...');
            for (const p of ready) {
              await utils.removeScheduledLabel(p.number);
            }

            const titles = ready.map(p => p.title).join('", "');
            console.log(`📝 Triggering build for ${ready.length} scheduled posts: "${titles}"`);
            await utils.triggerBuild('scheduled publish');
