# .github/workflows/scheduled-publishing.yml
name: Scheduled Publishing

# Configuration - customize these values for your setup
env:
  BLOG_CATEGORY: "Blog Post"                           # GitHub Discussions category name for blog posts
  IGNORE_LABELS: "state/draft"                         # Comma-separated labels to ignore (posts with these won't be published)
  SCHEDULED_LABEL: "state/scheduled"                   # Label name that marks posts as scheduled for future
  TIMEZONE_LOCATION: "Europe/London"                   # IANA timezone (auto-handles GMT/BST)

on:
  # Check for scheduled posts every 15 minutes
  schedule:
    - cron: '*/15 * * * *'
  
  # Immediate check when discussions change
  discussion:
    types: [created, edited, labeled, unlabeled]
  
  # Allow manual triggering
  workflow_dispatch:

jobs:
  check-and-publish:
    runs-on: ubuntu-latest
    steps:
      - name: Check for posts ready to publish
        uses: actions/github-script@v7
        # Skip scheduled label changes AND any ignore label changes
        if: |
          github.event_name != 'discussion' ||
          github.event.action == 'created' ||
          github.event.action == 'edited' ||
          (
            (github.event.action == 'labeled' || github.event.action == 'unlabeled') &&
            github.event.label.name != env.SCHEDULED_LABEL
          )
        env:
          NETLIFY_HOOK_URL: ${{ secrets.NETLIFY_BUILD_HOOK }}
        with:
          github-token: ${{ secrets.GH_PAT_TOKEN }}  # ‚Üê Use PAT instead
          script: |

            // Configuration from environment variables
            const CONFIG = {
              blogCategory: process.env.BLOG_CATEGORY,
              ignoreLabels: (process.env.IGNORE_LABELS || '').split(',').map(label => label.trim()).filter(Boolean),
              scheduledLabel: process.env.SCHEDULED_LABEL,
              timezoneLocation: process.env.TIMEZONE_LOCATION || 'UTC',
              defaultTimezone: process.env.DEFAULT_TIMEZONE  // Fallback for manual offset
            };
            
            // ===== UTILITY FUNCTIONS =====
            const utils = {

              async triggerBuild(reason = '') 
              {
                try {
                  await fetch(process.env.NETLIFY_HOOK_URL, { method: 'POST' });
                  console.log(`‚úÖ Build triggered${reason ? ': ' + reason : ''}`);
                  return true;
                } catch (error) {
                  console.error('‚ùå Error triggering build:', error.message);
                  return false;
                }
              },

              getCurrentTimezoneOffset() 
              {
                // Get current offset for the configured timezone
                const now = new Date();
                const utc = new Date(now.getTime() + (now.getTimezoneOffset() * 60000));
                const localTime = new Date(utc.toLocaleString('en-US', { timeZone: CONFIG.timezoneLocation }));
                const offset = Math.ceil(localTime.getTime() - utc.getTime()) / (1000 * 60); // offset in minutes
                
                // Convert to timezone string format (+HH:MM or -HH:MM)
                const hours = Math.floor(Math.abs(offset) / 60);
                const minutes = Math.abs(offset) % 60;
                const sign = offset >= 0 ? '+' : '-';
                
                return `${sign}${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
              },

              parseDateTime(dateStr) 
              {
                console.log(`Parsing date string: "${dateStr}"`);
                
                try 
                {
                  // Check if it already has timezone info
                  if (dateStr.includes('Z') || dateStr.match(/[+-]\d{2}:\d{2}$/)) {
                    console.log('Date has explicit timezone info');
                    const publishDate = new Date(dateStr);
                    
                    if (isNaN(publishDate.getTime())) {
                      console.log(`‚ùå Invalid date format: "${dateStr}"`);
                      return null;
                    }
                    
                    console.log(`‚úÖ Parsed with timezone: ${publishDate.toISOString()}`);
                    return publishDate;
                  }
                  
                  // No timezone info, apply location-based timezone
                  let timezoneOffset;
                  
                  if (CONFIG.timezoneLocation && CONFIG.timezoneLocation !== 'UTC') 
                  {
                    // Use location-based timezone (handles DST automatically)
                    timezoneOffset = this.getCurrentTimezoneOffset();
                    console.log(`No timezone info, applying ${CONFIG.timezoneLocation} timezone: ${timezoneOffset}`);
                    
                    // Check if we're in DST
                    const testDate = new Date(dateStr + 'T12:00:00');
                    const isDST = testDate.getTimezoneOffset() < new Date(testDate.getFullYear(), 0, 1).getTimezoneOffset();
                    console.log(`DST status for date: ${isDST ? 'Summer Time' : 'Standard Time'}`);
                  }
                  else 
                  {
                    // Default to UTC
                    timezoneOffset = '+00:00';
                    console.log(`No timezone configured, defaulting to UTC`);
                  }
                  
                  const dateWithTz = `${dateStr}${timezoneOffset}`;
                  console.log(`Full date string: "${dateWithTz}"`);
                  
                  const publishDate = new Date(dateWithTz);
                  
                  if (isNaN(publishDate.getTime())) {
                    console.log(`‚ùå Invalid date format: "${dateWithTz}"`);
                    return null;
                  }
                  
                  console.log(`‚úÖ Parsed with timezone: ${publishDate.toISOString()}`);
                  
                  // Show what this means in local time
                  if (CONFIG.timezoneLocation !== 'UTC') {
                    const localTimeStr = publishDate.toLocaleString('en-GB', { 
                      timeZone: CONFIG.timezoneLocation,
                      weekday: 'short',
                      year: 'numeric',
                      month: 'short', 
                      day: 'numeric',
                      hour: '2-digit',
                      minute: '2-digit',
                      timeZoneName: 'short'
                    });
                    console.log(`Local time: ${localTimeStr}`);
                  }
                  
                  return publishDate;
                } catch (error) {
                  console.log(`‚ùå Error parsing date "${dateStr}": ${error.message}`);
                  return null;
                }
              },
              
              parsePublishDate(discussion, now) 
              {
                const frontmatterMatch = discussion.body.match(/^---\s*\r?\n([\s\S]*?)\r?\n---\s*(\r?\n|$)/);
                if (!frontmatterMatch) {
                  return { publishDate: now, hasExplicitDate: false };
                }

                const publishedMatch = frontmatterMatch[1].match(/published:\s*(.+)/);
                if (!publishedMatch) {
                  return { publishDate: now, hasExplicitDate: false };
                }

                const publishedStr = publishedMatch[1].trim();
                console.log(`Found published field: "${publishedStr}"`);
                
                const parsedDate = this.parseDateTime(publishedStr);
                if (!parsedDate) {
                  console.log('Failed to parse date, defaulting to now');
                  return { publishDate: now, hasExplicitDate: false };
                }
                
                return { 
                  publishDate: parsedDate, 
                  hasExplicitDate: true 
                };
              },
              
              isValidBlogPost(discussion) 
              {
                // Check category
                if (discussion.category?.name !== CONFIG.blogCategory) {
                  return { valid: false, reason: `Not a ${CONFIG.blogCategory} post` };
                }
                
                // Check for any ignore labels
                const postLabels = discussion.labels?.map(label => label.name) || [];
                const hasIgnoreLabel = CONFIG.ignoreLabels.some(ignoreLabel => 
                  postLabels.includes(ignoreLabel)
                );
                
                if (hasIgnoreLabel) {
                  const matchedLabels = CONFIG.ignoreLabels.filter(ignoreLabel => 
                    postLabels.includes(ignoreLabel)
                  );
                  return { valid: false, reason: `Post has ignore label(s): ${matchedLabels.join(', ')}` };
                }
                
                return { valid: true };
              },
              
              async addScheduledLabel(discussionNumber)
              {
                try {
                  // For discussions, we need to use the GraphQL API, not REST
                  const mutation = `
                    mutation($discussionId: ID!, $labelIds: [ID!]!) {
                      addLabelsToLabelable(input: {
                        labelableId: $discussionId,
                        labelIds: $labelIds
                      }) {
                        clientMutationId
                      }
                    }
                  `;
                  
                  // First, get the label ID for the scheduled label
                  const labelsQuery = await github.rest.issues.listLabelsForRepo({
                    owner: context.repo.owner,
                    repo: context.repo.repo
                  });
                  
                  let scheduledLabelObj = labelsQuery.data.find(label => label.name === CONFIG.scheduledLabel);
                  
                  if (!scheduledLabelObj) {
                    console.log(`Creating ${CONFIG.scheduledLabel} label...`);
                    const newLabel = await github.rest.issues.createLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      name: CONFIG.scheduledLabel,
                      color: 'D4C5F9',
                      description: 'Post scheduled for future publication'
                    });
                    scheduledLabelObj = newLabel.data;
                  }
                  
                  // Get discussion node ID (different from number)
                  const discussionQuery = `
                    query($owner: String!, $repo: String!, $number: Int!) {
                      repository(owner: $owner, name: $repo) {
                        discussion(number: $number) {
                          id
                        }
                      }
                    }
                  `;
                  
                  const discussionResult = await github.graphql(discussionQuery, {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    number: discussionNumber
                  });
                  
                  const discussionId = discussionResult.repository.discussion.id;
                  
                  // Add the label using GraphQL
                  await github.graphql(mutation, {
                    discussionId: discussionId,
                    labelIds: [scheduledLabelObj.node_id]
                  });
                  
                  console.log(`‚úÖ Added ${CONFIG.scheduledLabel} label to discussion #${discussionNumber}`);
                } catch (error) {
                  console.warn(`Failed to add scheduled label: ${error.message}`);
                }
              },
              
              async removeScheduledLabel(discussionNumber) 
              {
                try {
                  // For discussions, we need to use the GraphQL API
                  const mutation = `
                    mutation($discussionId: ID!, $labelIds: [ID!]!) {
                      removeLabelsFromLabelable(input: {
                        labelableId: $discussionId,
                        labelIds: $labelIds
                      }) {
                        clientMutationId
                      }
                    }
                  `;
                  
                  // Get the label ID
                  const labelsQuery = await github.rest.issues.listLabelsForRepo({
                    owner: context.repo.owner,
                    repo: context.repo.repo
                  });
                  
                  const scheduledLabelObj = labelsQuery.data.find(label => label.name === CONFIG.scheduledLabel);
                  
                  if (!scheduledLabelObj) {
                    console.log(`${CONFIG.scheduledLabel} label doesn't exist, nothing to remove`);
                    return;
                  }
                  
                  // Get discussion node ID
                  const discussionQuery = `
                    query($owner: String!, $repo: String!, $number: Int!) {
                      repository(owner: $owner, name: $repo) {
                        discussion(number: $number) {
                          id
                        }
                      }
                    }
                  `;
                  
                  const discussionResult = await github.graphql(discussionQuery, {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    number: discussionNumber
                  });
                  
                  const discussionId = discussionResult.repository.discussion.id;
                  
                  // Remove the label using GraphQL
                  await github.graphql(mutation, {
                    discussionId: discussionId,
                    labelIds: [scheduledLabelObj.node_id]
                  });
                  
                  console.log(`‚úÖ Removed ${CONFIG.scheduledLabel} label from discussion #${discussionNumber}`);
                } catch (error) {
                  console.log(`Could not remove scheduled label: ${error.message} (may not exist)`);
                }
              }
            };
            
            // ===== MAIN LOGIC =====
            
            const eventType = context.eventName;
            const now = new Date();
            
            console.log(`üöÄ Running ${eventType} workflow at ${now.toISOString()}`);
            
            // If this is a discussion event, check if we should handle it
            if (eventType === 'discussion') 
            {
              const discussion = context.payload.discussion;
              console.log(`Discussion event: #${discussion.number} - "${discussion.title}"`);

              // Handle label events - process ignore label changes
              if (context.payload.action === 'labeled' || context.payload.action === 'unlabeled') {
                const changedLabel = context.payload.label?.name;
                if (CONFIG.ignoreLabels.includes(changedLabel)) {
                  if (context.payload.action === 'labeled') {
                    console.log(`üìã Ignore label "${changedLabel}" added to "${discussion.title}" - post will be ignored`);
                    await utils.removeScheduledLabel(discussion.number);
                    return;
                  } else {
                    console.log(`üìù Ignore label "${changedLabel}" removed from "${discussion.title}" - checking if ready to publish`);
                    // Continue with normal processing
                  }
                } else {
                  console.log(`Label change (${changedLabel}) not relevant to publishing, skipping`);
                  return;
                }
              }

              // Validate this is a publishable blog post
              const validation = utils.isValidBlogPost(discussion);
              if (!validation.valid) {
                console.log(validation.reason + ', skipping');
                return;
              }
              
              // Parse publish date
              const { publishDate, hasExplicitDate } = utils.parsePublishDate(discussion, now);
              console.log(`Published date: ${publishDate.toISOString()}${!hasExplicitDate ? ' (defaulted to now)' : ''}`);
              
              // If not ready yet, add scheduled label and skip
              if (publishDate > now) {
                const timeUntil = Math.round((publishDate - now) / (1000 * 60));
                console.log(`Post scheduled for future (${timeUntil} minutes from now), will be published by scheduled check`);
                await utils.addScheduledLabel(discussion.number);
                return;
              }
              
              // If we get here, post should be published now
              // Remove scheduled label if it exists
              await utils.removeScheduledLabel(discussion.number);
              
              // Trigger immediate build - no RSS check needed
              // (if discussion was edited, we want fresh build regardless)
              console.log(`üìù Triggering immediate build for "${discussion.title}"`);
              await utils.triggerBuild(`immediate publish`);
              return;
            }
            else
            {
              // Scheduled or manual run - check only scheduled discussions
              console.log('üîç Checking discussions with scheduled label...');
              
              const query = `
                query {
                  search(query: "repo:${{ github.repository }} category:\\"${CONFIG.blogCategory}\\" label:${CONFIG.scheduledLabel}", type: DISCUSSION, first: 100) {
                    edges {
                      node {
                        ... on Discussion {
                          id
                          number
                          title
                          body
                          createdAt
                        }
                      }
                    }
                  }
                }
              `;
              
              const result = await github.graphql(query);
              
              if (!result.search.edges.length) {
                console.log(`No posts with ${CONFIG.scheduledLabel} label found`);
                return;
              }
              
              const readyPosts = [];
              const stillScheduledPosts = [];
              
              // Check which scheduled posts are now ready
              for (const edge of result.search.edges) {
                const discussion = edge.node;
                const { publishDate } = utils.parsePublishDate(discussion, now);
                
                if (publishDate <= now) {
                  readyPosts.push({
                    id: discussion.id,
                    title: discussion.title,
                    number: discussion.number,
                    publishedDate: publishDate
                  });
                } else {
                  stillScheduledPosts.push({
                    title: discussion.title,
                    number: discussion.number,
                    publishedDate: publishDate
                  });
                }
              }
              
              // Log still-scheduled posts for visibility
              if (stillScheduledPosts.length > 0) {
                console.log(`üìÖ ${stillScheduledPosts.length} posts still scheduled for future:`);
                stillScheduledPosts
                  .sort((a, b) => a.publishedDate - b.publishedDate)
                  .forEach(post => {
                    const timeUntil = Math.round((post.publishedDate - now) / (1000 * 60));
                    console.log(`- "${post.title}" in ${timeUntil} minutes (${post.publishedDate.toISOString()})`);
                  });
              }
              
              if (readyPosts.length === 0) {
                console.log('No posts ready to publish now');
                return;
              }
              
              console.log(`Found ${readyPosts.length} posts that should be published:`);
              readyPosts.forEach(post => {
                console.log(`- "${post.title}" (Discussion #${post.number})`);
              });
              
              // For scheduled posts, trust the label and publish immediately
              console.log('Removing scheduled labels and triggering build...');
              for (const post of readyPosts) {
                await utils.removeScheduledLabel(post.number);
              }
              
              const titles = readyPosts.map(p => p.title).join('", "');
              console.log(`üìù Triggering build for ${readyPosts.length} scheduled posts: "${titles}"`);
              
              // Trigger build
              await utils.triggerBuild(`scheduled publish`);
            }